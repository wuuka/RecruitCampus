//剑指offer面试编程案例

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

using namespace std;

//01二维数组的查找
class Solution01 {
public:
	bool Find(int target, vector<vector<int> > array) {  //用两次vector来定义数组（动态数组定义）
		
		//vector定义数组的行列长度查找；
		int row = array.size();
		int col = array[0].size();

		//判断数组含有变量
		if (row > 0 && col > 0) {
			
			int i = 0, j = col - 1;
			while (i < row && j >= 0) {  //方案一：选用数组右上角的点数做判断
				if (array[i][j] == target)
					return true;
				else if (array[i][j] > target)
					j--;
				else
					i++;
			}

			/*
			int i_ = row - 1, j_ = 0;
			while (i_ >= 0 && j_ < col) {  //方案二：选用数组左下角的点数做判断
				if (array[i_][j_] == target)
					return true;
				else if (array[i_][j_] > target)
					i_--;
				else
					j_++;
			}*/
		}
		return false;
	}

	void test() {
		vector <vector<int>> array{ { 1, 2, 3, 4, 5 },
		{ 6, 7, 8, 9, 10 },
		{ 11, 12, 13, 14, 15 },
		{ 16, 17, 18, 19, 20 } };
		vector<int> target{ 1, 2, 3, 10, 0, -1, 32, 34, 20, 16, 15, 6 };

		for (int i = 0; i != target.size(); i++) {
			cout << "target " << target[i] << boolalpha <<  //bool类型数据显示
				"    std:" << (1 <= target[i] && target[i] <= 20) <<  //判断在（1， 20）范围之内
				"  res:"<< Find( target[i], array) << endl;
		}
	}

};

//02字符串空格的替换
class Solution02 {
public:
	void replaceSpace(char *str, int length) {  //输入字符串 str；数组内存空间长度length;

		if (str == NULL || length <= 0)  //判断字符串内存
			return;
		
		int numblank = 0, numlength = 0, i = 0;
		while(str[i] != '\0') {  //将原有字符串扩展后长度计算
			if (str[i] == ' ')
				++numblank;
			
			++numlength;
			++i;
		}

		int newlength = numlength + 2 * numblank;
		if (newlength > length)
			return;

		while (newlength != numlength) {  //将字符串从末尾开始添加“%20”，向前移动
			if (str[numlength] == ' ') {
				str[newlength--] = '0';
				str[newlength--] = '2';
				str[newlength--] = '%';
			}
			else { 
				str[newlength--] = str[numlength];
			}
			--numlength;
		}
	}

	void test() {
		vector<string> vec{ "We are Happy", "hello",
			"", "  hlee", "hll  ", "  srfe  ", "  se  sd " };
		for (int i = 0; i != vec.size(); i++) {
			char buf[256] = { 0 };
			strcpy_s(buf, vec[i].c_str());
			replaceSpace(buf, 256);
			cout << vec[i] << "   " << buf << endl;
		}
	}
};

//03从尾到头来打印链表
class Solution03 {
	struct ListNode {  //定义指针结构
		int val;
		struct ListNode *next;
		ListNode(int x) :
			val(x), next(NULL) {
		}
	};

public:	
        vector<int> dev;
	vector<int> printListFromTailToHead_recuit(ListNode* head) {  //采用递归的思想进行输出链表
		if (head != NULL) {
			if (head->next != NULL)
				dev = printListFromTailToHead_recuit(head->next);
			dev.push_back(head->val);
		}
		return dev;
	}

	void printListFromTailToHead_itler(ListNode* head) {  //使用栈先入后出的方式
		stack <ListNode*>node;
		ListNode* pnode = head;
		while (pnode != NULL) {
			node.push(pnode);
			pnode = pnode->next;
		}
		while (!node.empty()) {
			cout << node.top()->val << endl;
			node.pop();
		}
	}

	void test() {
		vector<int> vector_list;
		ListNode myHead(0), a(1), b(2), c(3), d(4), e(5), f(6);
		myHead.next = &a, a.next = &b, b.next = &c, c.next = &d,
			d.next = &e, e.next = &f;
		printListFromTailToHead_itler(&myHead);

		vector_list = printListFromTailToHead_recuit(&myHead);
		for (auto item : vector_list)
			cout << item << endl;
	}
};



int main()
{
	Solution03 temp;  //调用实用类
	temp.test();

	system("pause");
	return 0;
}
